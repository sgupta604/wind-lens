# Research: performance-optimization

## Metadata
- **Feature:** performance-optimization
- **Created:** 2026-02-02T21:49
- **Status:** research-complete
- **Researcher:** research-agent

---

## CRITICAL CONSTRAINT

> **"It is critical that you don't break what works already"** - User

All optimizations MUST:
1. Preserve existing functionality
2. Be thoroughly tested
3. Be incremental (one change at a time)
4. Include rollback capability
5. Not introduce new visual artifacts

---

## Feature Context

**From ROADMAP_PHASE2.md:**
- Order: #8 (listed) but recommended as #1 in Phase 2a
- Priority: Medium (but effectively High due to user impact)
- Complexity: Medium
- Depends on: None
- Blocking: None (but affects user experience of all features)

**From STATUS.md:**
- MVP + all post-MVP bugs complete
- Current FPS: 5 (target: 45-60)
- Performance manager has reduced particles to 976 (from 2000)

**From User Screenshot (IMG_4343.PNG):**
- FPS: 5
- Particles: 976
- Sky Cal: Yes
- Sky: 37.0%
- Pitch: -88.5 (pointing nearly straight down)

---

## Requirements from Spec

### Source Sections
- CLAUDE.md - Performance Targets
- CLAUDE.md - Performance Warning
- ROADMAP_PHASE2.md - Feature 8: performance-optimization

### Functional Requirements
- [ ] FR1: Maintain 45+ FPS on target devices
- [ ] FR2: Adaptive particle reduction when needed
- [ ] FR3: No jank or stuttering
- [ ] FR4: Preserve all existing visual effects

### Technical Requirements
- [ ] TR1: Frame rate: 60 FPS target, 45 FPS minimum
- [ ] TR2: Particle count: 2000 at 60 FPS, auto-reduce to 1000 if <45 FPS
- [ ] TR3: Sky detection: processFrame() < 16ms per frame
- [ ] TR4: NO object allocation in render loop
- [ ] TR5: Pre-allocate all data arrays

### Performance Targets from CLAUDE.md
```
- Particle count: 2000 (auto-reduce to 1000 if <45 FPS)
- Frame rate: 60 FPS target
- Sky detection: processFrame() < 16ms
```

### Warnings from CLAUDE.md
> **"NO object allocation in render loop! Bilinear interpolation for 2000 particles at 60 FPS = 120,000 calculations/second. Pre-allocate grid data arrays, interpolate directly into reusable fields."**

---

## Existing Code Analysis

### Project State
- Flutter project exists: YES
- All MVP features complete: YES
- All post-MVP bugs fixed: YES
- 254 tests passing

### Performance-Critical Files

#### 1. `lib/widgets/particle_overlay.dart` (411 lines)

**Current Implementation:**
- Pre-allocated particle pool (good)
- Ticker-based animation at 60 FPS (good)
- 2-pass glow rendering (potentially expensive)

**IDENTIFIED ISSUES:**

**Issue P1: `setState(() {})` called every frame (line 309)**
```dart
void _onTick(Duration elapsed) {
  // ... particle updates ...
  setState(() {});  // PROBLEM: Triggers full widget rebuild every frame
}
```
This triggers a full rebuild of the widget tree on EVERY frame. With 60 FPS target, this is 60 full rebuilds per second.

**Issue P2: Sky mask check per particle twice (lines 292, 373)**
```dart
// In _onTick - particle reset check:
if (p.isExpired || !widget.skyMask.isPointInSky(p.x, p.y)) {  // Check 1

// In paint() - render check:
if (!skyMask.isPointInSky(p.x, p.y)) {  // Check 2
```
For 2000 particles, this is 4000 sky mask lookups per frame.

**Issue P3: `Color.withValues()` called per particle in render loop (lines 396, 400)**
```dart
_glowPaint.color = color.withValues(alpha: baseOpacity * 0.3);  // Allocation?
_corePaint.color = color.withValues(alpha: baseOpacity * 0.9);  // Allocation?
```
Called 2000 times per frame. `withValues()` may allocate new Color objects.

**Issue P4: `sin()` calculation per particle (line 379)**
```dart
final baseOpacity = sin(p.age * 3.14159).clamp(0.0, 1.0);
```
2000 sin() calculations per frame - could use lookup table.

**Issue P5: Offset allocation per particle (lines 392-393)**
```dart
final start = Offset(startX, startY);  // New Offset object
final end = Offset(endX, endY);        // New Offset object
```
4000 Offset allocations per frame.

#### 2. `lib/services/sky_detection/auto_calibrating_sky_detector.dart` (509 lines)

**Current Implementation:**
- Downscaled to 128x96 (12,288 pixels vs full res) - good
- Pre-allocated mask buffer - good
- debugPrint on every frame (line 414) - BAD

**IDENTIFIED ISSUES:**

**Issue S1: debugPrint() called every frame (line 414)**
```dart
debugPrint('Sky fraction: ${(_cachedSkyFraction * 100).toStringAsFixed(1)}%');
```
String formatting and print I/O on EVERY camera frame. This is likely the BIGGEST bottleneck.

**Issue S2: debugPrint() in calibration (line 266)**
```dart
debugPrint('Sky calibrated: ${samples.length} samples, profile=$_skyHistogram');
```
Less critical but still allocates strings.

**Issue S3: HSV object allocation per pixel (lines 298, 345, 387-389, 441, 470)**
```dart
samples.add(ColorUtils.rgbToHsv(r, g, b));  // New HSV object
```
During mask generation, creates HSV object for each of 12,288 pixels.

**Issue S4: List allocation for RGB conversion (color_utils.dart line 87)**
```dart
return [r, g, b];  // New list allocation per pixel
```
For YUV conversion, allocates a new List<int> per pixel.

#### 3. `lib/services/compass_service.dart` (151 lines)

**IDENTIFIED ISSUES:**

**Issue C1: debugPrint() on every sensor update (line 130-133)**
```dart
debugPrint(
  'Heading: ${_smoothedHeading.toStringAsFixed(1)}°, '
  'Pitch: ${_smoothedPitch.toStringAsFixed(1)}°',
);
```
Called every time sensors fire (potentially 50-100Hz). String formatting on hot path.

#### 4. `lib/screens/ar_view_screen.dart` (316 lines)

**IDENTIFIED ISSUES:**

**Issue A1: setState() in _onCameraFrame (lines 131-137)**
```dart
if ((newFraction - _skyFraction).abs() > 0.01 ||
    newCalibrated != _isCalibrated) {
  setState(() {
    _skyFraction = newFraction;
    _isCalibrated = newCalibrated;
  });
}
```
This is gated by change detection - reasonable.

**Issue A2: setState() in _onCompassUpdate (lines 105-118)**
```dart
void _onCompassUpdate(CompassData data) {
  setState(() {
    // Update all state
  });
}
```
Called on every compass update (~50Hz). Triggers full widget rebuild.

#### 5. `lib/services/performance_manager.dart` (132 lines)

**Current Implementation:**
- Rolling window of 30 frames
- Adjusts at 45 FPS threshold
- Reduces to 70% on low FPS

**IDENTIFIED ISSUES:**

**Issue M1: List operations in hot path (lines 85-89)**
```dart
_recentFps.add(clampedFps);
if (_recentFps.length > _fpsWindowSize) {
  _recentFps.removeAt(0);  // O(n) removal from start
}
```
`removeAt(0)` is O(n) - should use circular buffer.

**Issue M2: reduce() called every frame (line 94)**
```dart
_currentFps = _recentFps.reduce((a, b) => a + b) / _recentFps.length;
```
Iterates entire list on every frame - could maintain running sum.

---

## Root Cause Analysis

Based on code analysis, the 5 FPS issue is likely caused by a combination of:

### Primary Causes (HIGH IMPACT)

1. **debugPrint() spam** - Multiple debugPrint calls on every frame/sensor update:
   - Sky detection: prints every frame
   - Compass: prints every sensor update
   - Camera: prints on init (minor)
   - Estimated impact: 50-80% of performance loss

2. **setState() called every tick** in ParticleOverlay:
   - Triggers full widget rebuild 60x/second
   - Flutter's build/layout/paint cycle is expensive
   - Estimated impact: 20-40% of performance loss

### Secondary Causes (MEDIUM IMPACT)

3. **Object allocation in render loop:**
   - 4000 Offset objects per frame
   - 4000 Color.withValues() calls per frame
   - HSV objects during mask generation
   - List allocations in YUV conversion

4. **Redundant calculations:**
   - sin() per particle (could cache/LUT)
   - Double sky mask lookup per particle

### Tertiary Causes (LOW IMPACT)

5. **Inefficient data structures:**
   - PerformanceManager uses O(n) list removal
   - Could use circular buffer

---

## Recommended Fix Priority

### Priority 1: Remove/Gate debugPrint calls (QUICK WIN)

**Files to modify:**
- `auto_calibrating_sky_detector.dart` - Remove line 414 debugPrint
- `compass_service.dart` - Remove lines 130-133 debugPrint
- Consider: Add `kDebugMode` gate if prints are needed for debugging

**Expected impact:** Potentially 50-80% FPS improvement

### Priority 2: Optimize ParticleOverlay setState()

**Options:**
a) Use `RepaintBoundary` + `CustomPainter.shouldRepaint`
b) Use `AnimatedBuilder` pattern
c) Use `Ticker` with direct `markNeedsPaint()` instead of setState

**Expected impact:** 20-40% FPS improvement

### Priority 3: Reduce allocations in render loop

**Specific fixes:**
- Pre-allocate Offset arrays for particles
- Cache Color objects with common alpha values
- Use mutable HSV struct instead of allocating
- Use fixed-size array for RGB conversion

**Expected impact:** 10-20% FPS improvement

### Priority 4: Optimize sky mask lookups

**Options:**
- Skip render-time check if particle was just reset to valid position
- Batch sky mask checks
- Cache mask as texture for GPU access

**Expected impact:** 5-10% FPS improvement

### Priority 5: Use circular buffer in PerformanceManager

**Fix:** Replace List with fixed-size circular buffer

**Expected impact:** Negligible but good practice

---

## Risk Assessment

### Technical Risks
| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| Breaking visual appearance | High | Medium | Test each change individually |
| Introducing new bugs | High | Medium | Run full test suite after each change |
| Platform-specific issues | Medium | Low | Test on both iOS and Android |
| Insufficient improvement | Medium | Low | Profile after each fix to verify |

### Complexity
- **Level:** Medium
- **Rationale:**
  - Multiple small changes rather than one big refactor
  - Each change is low-risk individually
  - Need to profile to confirm root causes

---

## Open Questions

- [x] Q1: What is the actual frame rate of camera stream?
  - Resolution: Camera runs at device default (likely 30 FPS)
  - Sky detection processes every frame

- [x] Q2: Should we profile before fixing obvious issues?
  - Resolution: Quick wins (debugPrint removal) can be done immediately
  - Profile after to verify remaining bottlenecks

- [x] Q3: Is debug logging needed for production?
  - Resolution: No - can be removed or gated behind kDebugMode
  - User already has debug panel for runtime info

- [x] Q4: Should PerformanceManager threshold be adjusted?
  - Resolution: Yes - it's reducing to 976 particles but FPS is still 5
  - The problem is not particle count, it's per-frame overhead

---

## Recommended Approach

### Implementation Strategy

**Phase 1: Quick Wins (Estimated: +40-80% FPS)**
1. Remove all debugPrint calls from hot paths
2. Gate any necessary debug logging behind `kDebugMode`
3. Test - should see immediate FPS improvement

**Phase 2: Widget Optimization (Estimated: +20-40% FPS)**
1. Refactor ParticleOverlay to not use setState()
2. Use direct `markNeedsPaint()` or AnimatedBuilder pattern
3. Test - verify smooth animation

**Phase 3: Allocation Reduction (Estimated: +10-20% FPS)**
1. Pre-allocate Offset arrays
2. Cache Color objects
3. Optimize HSV/RGB conversion to avoid allocations
4. Test - verify no visual regressions

**Phase 4: Fine-tuning**
1. Profile on device to find remaining bottlenecks
2. Optimize as needed
3. Adjust PerformanceManager thresholds if needed

### Order of Implementation
1. Remove debugPrint (safest, biggest impact)
2. Optimize ParticleOverlay rebuild
3. Pre-allocate render objects
4. Optimize sky detection allocations
5. Circular buffer for PerformanceManager

### What to Defer (Not MVP Critical)
- GPU-based particle rendering (WebGL/OpenGL)
- ML-based sky detection optimization
- Advanced particle LOD system

---

## Testing Strategy

### Performance Testing
1. Profile FPS before each change
2. Profile FPS after each change
3. Document improvement percentage
4. Test on real device (not simulator)

### Regression Testing
1. Run all 254 existing tests
2. Visual inspection of particle animation
3. Verify sky detection still works
4. Verify all altitude levels render correctly
5. Verify world anchoring still works

### Devices to Test
- iOS device (user's primary platform based on screenshot)
- Android device (if available)

---

## Code Examples from Spec

### From CLAUDE.md - Pre-allocation Pattern
```dart
// PRE-ALLOCATE (good)
final List<Particle> _particles = List.generate(
  2000,
  (_) => Particle(),
);

// NO allocation in render loop
for (final p in _particles) {
  p.x += velocity;  // Mutate in place
}
```

### From CLAUDE.md - Performance Target
```dart
// Target: processFrame() < 16ms
void processFrame(CameraImage image) {
  // Must complete in under 16ms for 60 FPS
}
```

---

## Files to Create/Modify

### Files to Modify
1. `/workspace/wind_lens/lib/services/sky_detection/auto_calibrating_sky_detector.dart`
   - Remove debugPrint on line 414
   - Gate calibration debugPrint behind kDebugMode

2. `/workspace/wind_lens/lib/services/compass_service.dart`
   - Remove/gate debugPrint on lines 130-133

3. `/workspace/wind_lens/lib/widgets/particle_overlay.dart`
   - Refactor to avoid setState() every frame
   - Pre-allocate Offset arrays
   - Cache Color objects

4. `/workspace/wind_lens/lib/utils/color_utils.dart`
   - Optimize yuvToRgb() to avoid List allocation

5. `/workspace/wind_lens/lib/services/performance_manager.dart`
   - Replace List with circular buffer

### Files to Review After Changes
- All test files to ensure no regressions
- `ar_view_screen.dart` - verify integration still works

---

## Success Criteria

1. FPS >= 45 on real device (from current 5)
2. All 254 tests still passing
3. No visual regressions in particle rendering
4. Sky detection still works correctly
5. World anchoring still works correctly
6. Debug panel still shows correct metrics

---

## Next Step

**Ready for planning.**

Run `/plan performance-optimization` to create implementation plan with specific tasks.

---

## Appendix: Screenshot Analysis

From `/workspace/IMG_4343.PNG`:
- Device: iPhone (based on status bar style)
- Time: 3:04
- FPS: 5 (displayed in debug panel)
- Particles: 976 (reduced from 2000)
- Sky Cal: Yes (calibration complete)
- Sky: 37.0%
- Pitch: -88.5 degrees (pointing down)
- PerformanceManager already reduced particles to ~50% but FPS still terrible
- This confirms the bottleneck is NOT particle count - it's per-frame overhead

The fact that PerformanceManager reduced to 976 particles and FPS is still 5 strongly suggests the issue is:
1. debugPrint() spam (I/O blocking)
2. setState() overhead (widget rebuilds)
3. NOT the particle rendering itself
