# Implementation Plan: wind-animation

## Metadata
- **Feature:** wind-animation
- **Created:** 2026-01-21T02:15
- **Status:** planning-complete
- **Based On:** 2026-01-21T02:15_research.md

## Overview

This feature adds dynamic wind-driven particle animation to the Wind Lens app. Particles will flow in the wind direction, stay "world-fixed" (adjusting for compass heading), and have their speed and trail length driven by wind data.

## Architecture Overview

```
┌─────────────────────────────────────────────────────────────────┐
│                        ARViewScreen                              │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐ │
│  │ CompassService  │  │ FakeWindService │  │ PitchBasedSky   │ │
│  │                 │  │     (NEW)       │  │     Mask        │ │
│  │ heading: 127°   │  │                 │  │                 │ │
│  │ pitch: 12°      │  │ u: 3.5 m/s      │  │ skyFraction:65% │ │
│  └────────┬────────┘  │ v: 2.1 m/s      │  └────────┬────────┘ │
│           │           │ speed: 4.1 m/s  │           │          │
│           │           │ direction: 239° │           │          │
│           │           └────────┬────────┘           │          │
│           │                    │                    │          │
│           └────────────┬───────┴────────────────────┘          │
│                        ▼                                        │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │                   ParticleOverlay (MODIFIED)              │  │
│  │  ┌──────────────────────────────────────────────────┐    │  │
│  │  │ _onTick(elapsed):                                 │    │  │
│  │  │   screenAngle = windDirection - compassHeading    │    │  │
│  │  │   for each particle:                              │    │  │
│  │  │     p.x += cos(screenAngle) * speedFactor * dt    │    │  │
│  │  │     p.y -= sin(screenAngle) * speedFactor * dt    │    │  │
│  │  │     p.trailLength = windSpeed * 0.5               │    │  │
│  │  └──────────────────────────────────────────────────┘    │  │
│  └──────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

## Tech Stack Summary

- **Framework:** Flutter 3.x with Dart
- **Math:** `dart:math` (sqrt, atan2, cos, sin)
- **Existing Dependencies:** sensors_plus (for compass)
- **No New Dependencies Required**

## File Structure

### New Files to Create

| File | Purpose | Lines (Est.) |
|------|---------|--------------|
| `lib/models/wind_data.dart` | WindData model with u/v components, computed speed/direction | ~50 |
| `lib/services/fake_wind_service.dart` | Simulated wind data with time-varying oscillation | ~40 |
| `test/models/wind_data_test.dart` | Unit tests for WindData model | ~100 |
| `test/services/fake_wind_service_test.dart` | Unit tests for FakeWindService | ~60 |

### Files to Modify

| File | Changes | Location |
|------|---------|----------|
| `lib/widgets/particle_overlay.dart` | Add compass heading param, update particle movement in _onTick, pass wind data to painter | Lines 27-42 (params), Lines 99-127 (_onTick), Lines 179-227 (paint) |
| `lib/screens/ar_view_screen.dart` | Create FakeWindService, pass heading and wind to ParticleOverlay | Lines 25-42 (state), Lines 78-81 (ParticleOverlay call) |
| `test/widgets/particle_overlay_test.dart` | Add tests for wind-driven movement | Append new test groups |

## Data Model: WindData

```dart
class WindData {
  final double uComponent;      // m/s, positive = eastward
  final double vComponent;      // m/s, positive = northward
  final double altitude;        // meters above sea level
  final DateTime timestamp;

  const WindData({
    required this.uComponent,
    required this.vComponent,
    required this.altitude,
    required this.timestamp,
  });

  // Computed properties (no allocation)
  double get speed => sqrt(uComponent * uComponent + vComponent * vComponent);
  double get directionRadians => atan2(-uComponent, -vComponent);
  double get directionDegrees => (directionRadians * 180 / pi + 360) % 360;

  // Factory for zero wind (useful for initialization)
  static WindData zero() => WindData(
    uComponent: 0,
    vComponent: 0,
    altitude: 0,
    timestamp: DateTime.now(),
  );
}
```

## Component Architecture

### ParticleOverlay Changes

```
ParticleOverlay (StatefulWidget)
├── Props (new/modified):
│   ├── skyMask: SkyMask (existing)
│   ├── particleCount: int = 2000 (existing)
│   ├── windAngle: double (REMOVE - replaced by windData)
│   ├── windData: WindData (NEW)
│   └── compassHeading: double (NEW - degrees)
│
├── State:
│   ├── _particles: List<Particle> (existing)
│   ├── _ticker: Ticker (existing)
│   └── _random: Random (existing)
│
└── _onTick() changes:
    1. Calculate screenAngle from windData and compassHeading
    2. Calculate speedFactor from windData.speed
    3. Update particle positions based on screenAngle
    4. Update particle trailLength based on windData.speed
    5. Wrap particles that move off-screen (instead of just aging)
```

### ParticleOverlayPainter Changes

```
ParticleOverlayPainter (CustomPainter)
├── Props (modified):
│   ├── particles: List<Particle> (existing)
│   ├── skyMask: SkyMask (existing)
│   ├── windAngle: double (KEEP for trail direction)
│   └── color: Color (existing)
│
└── paint() - no changes needed
    (windAngle already used for trail direction)
```

### ARViewScreen Changes

```
ARViewScreen (StatefulWidget)
├── State (new):
│   ├── _windService: FakeWindService (NEW)
│   └── _windData: WindData (NEW)
│
├── initState():
│   └── Initialize _windService and _windData
│
├── _onCompassUpdate():
│   └── Update _windData from service
│
└── build():
    └── Pass windData and heading to ParticleOverlay
```

## Movement Calculation Detail

```dart
// In ParticleOverlay._onTick():

// 1. Calculate screen-space angle
//    windDirection is in radians (meteorological: direction wind comes FROM)
//    compassHeading is in degrees (0-360, clockwise from North)
final windAngle = widget.windData.directionRadians;
final compassRad = widget.compassHeading * pi / 180;
final screenAngle = windAngle - compassRad;

// 2. Calculate speed factor
//    m/s → screen fraction per second (0.002 multiplier from spec)
final speedFactor = widget.windData.speed * 0.002;

// 3. Update each particle
for (final p in _particles) {
  // Move particle (screen Y is inverted)
  p.x += cos(screenAngle) * speedFactor * dt;
  p.y -= sin(screenAngle) * speedFactor * dt;

  // Update trail length based on wind speed
  p.trailLength = widget.windData.speed * 0.5;

  // Age the particle
  p.age += dt * 0.3;

  // Wrap around screen edges (not just reset on expire)
  if (p.x < 0) p.x += 1.0;
  if (p.x > 1) p.x -= 1.0;
  if (p.y < 0) p.y += 1.0;
  if (p.y > 1) p.y -= 1.0;

  // Reset expired particles
  if (p.isExpired) {
    p.reset(_random);
  }
}
```

## Testing Strategy

### Unit Tests (6 tests)

| Test File | Test Count | Coverage |
|-----------|------------|----------|
| `wind_data_test.dart` | 8 | Constructor, speed calculation, direction calculation, edge cases |
| `fake_wind_service_test.dart` | 4 | getWind() returns valid data, values vary over time, speed in expected range |

### Widget Tests (4 tests)

| Test File | Test Count | Coverage |
|-----------|------------|----------|
| `particle_overlay_test.dart` | 4 | Wind parameters accepted, particles move, trail length updates |

### Integration Tests (Manual)

| Test | Verification |
|------|--------------|
| Rotate phone | Particles maintain world-fixed direction |
| Observe over time | Particles flow consistently |
| Check FPS | Maintains 60 FPS with wind animation |

## Implementation Notes

### Decisions Made

1. **Keep windAngle in painter:** The painter uses windAngle for trail direction. Rather than passing full WindData, we calculate screenAngle in the state and pass it as windAngle.

2. **Wrap vs Reset:** Particles that move off-screen should wrap around (appear on opposite edge) rather than reset randomly. This creates more realistic wind flow.

3. **Trail length dynamic:** Trail length changes based on wind speed (wind.speed * 0.5 pixels). Faster wind = longer trails.

4. **No object allocation:** WindData is passed as a widget parameter, not created in the render loop. The only allocation is the DateTime in FakeWindService, which is acceptable (happens once per call, not per particle).

### Performance Considerations

- **No new allocations in render loop:** All calculations use primitives
- **Trigonometry calls:** 2 per frame (cos, sin for movement) - negligible cost
- **WindData getter calls:** `speed` and `directionRadians` called once per frame, each does ~3 operations

### Patterns Used

- **Dependency Injection:** FakeWindService injected into screen, easily swappable for real API later
- **Computed Properties:** WindData computes speed/direction from u/v on demand (no caching needed, fast math)
- **Screen Coordinate System:** Normalized 0-1 coordinates with Y-inverted movement

## Non-Goals (Explicit)

- Real wind API integration (future feature)
- Multiple altitude levels (future feature: altitude-depth)
- Wind speed visualization UI (e.g., speedometer)
- Wind direction indicator/compass rose
- Persistent wind data caching

## Risks and Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| Frame rate drop | Poor UX | Use delta-time, verify 60 FPS in tests |
| Jittery particles | Visual quality | Compass already smoothed (0.1 factor) |
| Wrong direction math | Looks fake | Test atan2(-u,-v) convention explicitly |
| Objects allocated in loop | GC stutter | Code review: no `new` in _onTick |

## Dependencies

- **Depends On:** `particle-system` (complete), `compass-sensors` (complete)
- **Required By:** `altitude-depth` (will add per-altitude wind)

## Performance Budget

| Operation | Budget | Expected |
|-----------|--------|----------|
| FakeWindService.getWind() | <1ms | ~0.01ms |
| Screen angle calculation | <1ms | ~0.001ms |
| Particle movement (2000) | 2ms | ~1ms |
| **Total added per frame** | **<4ms** | **~1ms** |

Current particle system: ~6ms per 16ms frame
With wind animation: ~7ms per 16ms frame (well within budget)

## Success Criteria

- [ ] WindData model created with correct speed/direction math
- [ ] FakeWindService provides oscillating wind data
- [ ] Particles move in wind direction
- [ ] Direction adjusts for compass heading (world-fixed)
- [ ] Trail length varies with wind speed
- [ ] Animation maintains 60 FPS
- [ ] All tests pass
